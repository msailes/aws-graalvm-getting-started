[{"type":"Page","content":[{"id":"getting-started-with-aws-lambda-and-graalvm","title":"Getting started with AWS Lambda and GraalVM","type":"Section","content":[{"type":"Paragraph","content":[{"text":"This repository is to help developers to create and migration Java applications to AWS Lambda using GraalVM native-image. It will cover multiple different frameworks and strategies to help you modernize your applications whatever situation you are in.","type":"SimpleText"}]}]}],"lastModifiedTime":1661114960850,"tocItem":{"chapterTitle":"","pageTitle":"AWS Lambda and GraalVM","pageMeta":{},"dirName":"","fileName":"index","viewOnRelativePath":null,"pageSectionIdTitles":[{"title":"Getting started with AWS Lambda and GraalVM","id":"getting-started-with-aws-lambda-and-graalvm"}]}},{"type":"Page","content":[{"id":"overview","title":"Overview","type":"Section","content":[{"type":"Paragraph","content":[{"text":"GraalVM is a high-performance JDK designed for high performance and low memory utilization. GraalVM can run in two different modes. Firstly, on the HotSpot JVM with the Graal just-in-time (JIT) compiler. Secondly, and more interesting for this repository is the ahead-of-time (AOT) compiled native binaries.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"Using the GraalVM native-image tool you can compile Java bytecode into a self contained, platform specific binary file. This executable no longer requires the JVM to run. This and the ahead-of-time compilation mean that the application can start up much faster and consume less memory.","type":"SimpleText"}]}]},{"id":"advantages","title":"Advantages","type":"Section","content":[{"type":"Paragraph","content":[{"text":"AWS Lambda automatically scales to support the rate of incoming requests. When a Lambda function doesn't currently have sufficient capacity to handle a request a new execution environment is created. Each execution environment can handle a single request at once. When a new execution environment is created, the Java Virtual Machine (JVM) is started and the your code is loaded into it. This is called a cold start. The execution environment can then be re-used for subsequent invocations. This is called a warm start. Execution environments are reused for a nondeterministic period of time, before they are shutdown.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"Each cold start represents hundreds of milliseconds of latency to a function call. Loading your code and executing runtime specific functionality and add even further to the latency. The JVMs JIT compilers work by identifying hot spots of your code by profiling your functions as they run. Peak performance comes after a period of time.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"With a GraalVM native executable, your Lambda function no longer needs a JVM in order to run so it doesn't need to be started. It also comes pre-optimized, so there is no period of profiling before it reaches peak performance.","type":"SimpleText"}]}]},{"id":"limitations","title":"Limitations","type":"Section","content":[{"id":"limitations-java-language-incompatibilities","level":2,"title":"Java language incompatibilities","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"GraalVM native-image is an optimization, and with this optimization comes trade-offs. To produce the native executable the native-image tool statically analyses all reachable code from the entry point of the application. Only classes and methods found like this are included into the native executable. This limits your application to code which is known at build time. Nothing new can be loaded at runtime. This means that common functionality like dynamic class loading and reflection is not supported. The GraalVM manual documents an in-depth list of ","type":"SimpleText"},{"url":"https://www.graalvm.org/22.0/reference-manual/native-image/Limitations/","isFile":false,"type":"Link","content":[{"text":"limitations","type":"SimpleText"}]},{"text":".","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"To work around these limitations you create additional configuration files which the native-image tool uses to find additional resources for inclusion.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"For example, the Java class which implements the ","type":"SimpleText"},{"code":"RequestHandler","type":"InlinedCode"},{"text":" or ","type":"SimpleText"},{"code":"RequestStreamHandler","type":"InlinedCode"},{"text":" interface is loaded using reflection by the Lambda runtime. This would need to be configured using additional ","type":"SimpleText"},{"url":"https://www.graalvm.org/22.0/reference-manual/native-image/BuildConfiguration/","isFile":false,"type":"Link","content":[{"text":"build configuration","type":"SimpleText"}]},{"text":".","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"reflect-config.json","type":"SimpleText"}]},{"data":[{"name":"com.retail.UpdateOrderHandler","allDeclaredConstructors":true,"allPublicConstructors":true,"allDeclaredMethods":true,"allPublicMethods":true,"allDeclaredClasses":true,"allPublicClasses":true}],"paths":[],"type":"Json"},{"id":"limitations-increased-build-complexity","level":2,"title":"Increased Build Complexity","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"The ahead-of-time compilation done by the native-image tool is more resource intensive than that done by the JVM. Builds take longer and require more memory. The resultant binary executable is also platform specific.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"Lambda supports two CPU architectures x86 and ARM. You must ensure that the product of your build process matches that of your target Lambda function. In the same way, the build must target the Linux operating system.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"If you are using a different OS or CPU architecture to your desired target then you can use ","type":"SimpleText"},{"url":"https://www.docker.com/","isFile":false,"type":"Link","content":[{"text":"Docker","type":"SimpleText"}]},{"text":" to produce a suitable build.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"TODO: error message example","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"For example:","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"with x CPU and x Memory","type":"SimpleText"}]},{"table":{"columns":[{"title":"Project","align":"left"},{"title":"JVM (Java 17)","align":"left"},{"title":"AOT (GraalVM 22.1.0)","align":"left"}],"data":[[[{"url":"https://github.com/aws-samples/serverless-graalvm-demo","isFile":false,"type":"Link","content":[{"text":"graalvm-serverless-demo","type":"SimpleText"}]}],[{"text":"xxs","type":"SimpleText"}],[{"text":"xxxs","type":"SimpleText"}]]]},"type":"Table"}]},{"id":"dependency-considerations","title":"Dependency Considerations","type":"Section","content":[{"type":"Paragraph","content":[{"text":"External dependencies are often used to add additional capabilities to our application which might be lengthy or complex to write yourself. They can also give productivity boosts by simplifying processes. To do this, they often use the very functionality which is not supported in GraalVM native-image. For example the Jackson databind library uses reflection to serialise and de-serialise objects to JSON. Serialising complex objects to JSON is a non-trivial operation, so it make sense to use a high quality external dependency.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"Not all external dependencies currently support GraalVM native-image. When you use them in your application and compile them with native-image you can have runtime exceptions due to ","type":"SimpleText"},{"code":"ClassNotFoundExceptions","type":"InlinedCode"},{"text":". This is the worst time to have errors surface. In the testing section, strategies for avoiding this will be covered. (TODO: Link)","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"TODO: example error message","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"Adoption of GraalVM native-image is increasing. The eco-systems largest framework, Spring has stated that ","type":"SimpleText"},{"url":"https://www.infoq.com/articles/native-java-spring-boot/","isFile":false,"type":"Link","content":[{"text":"Spring Boot 3 and Spring Framework 6 will have built-in support","type":"SimpleText"}]},{"text":" by the end of 2022.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"The following table is a list of common dependencies and information about what support they provide for GraalVM native-image.","type":"SimpleText"}]},{"id":"dependency-considerations-aws-dependencies","level":2,"title":"AWS Dependencies","type":"SubHeading"},{"table":{"columns":[{"title":"Name","align":"left"},{"title":"Supported","align":"left"},{"title":"Information","align":"left"}],"data":[[[{"text":"AWS SDK for Java v2","type":"SimpleText"}],[{"text":":white_check_mark: Supported","type":"SimpleText"}],[{"text":"Supported from ","type":"SimpleText"},{"url":"https://aws.amazon.com/blogs/developer/graalvm-native-image-support-in-the-aws-sdk-for-java-2-x/","isFile":false,"type":"Link","content":[{"text":"v2.16.1","type":"SimpleText"}]}]],[[{"text":"AWS Lambda Java Libs","type":"SimpleText"}],[{"text":":page_facing_up: Config available","type":"SimpleText"}],[{"text":"Follow the ","type":"SimpleText"},{"url":"https://github.com/aws/aws-lambda-java-libs/issues/272","isFile":false,"type":"Link","content":[{"text":"GitHub issue","type":"SimpleText"}]}]],[[{"text":"AWS X-Ray SDK for Java","type":"SimpleText"}],[{"text":":white_check_mark: Supported","type":"SimpleText"}],[{"text":"Supported from v2.11.0","type":"SimpleText"}]]]},"type":"Table"},{"id":"dependency-considerations-3rd-party-dependencies","level":2,"title":"3rd Party Dependencies","type":"SubHeading"},{"table":{"columns":[{"title":"Name","align":"left"},{"title":"Supported","align":"left"},{"title":"Information","align":"left"}],"data":[[[{"text":"Jackson","type":"SimpleText"}],[{"text":":x: Unsupported","type":"SimpleText"}],null]]},"type":"Table"},{"id":"dependency-considerations-graalvm-reachability-metadata-repository","level":2,"title":"GraalVM Reachability Metadata Repository","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"The GraalVM Reachability Metadata Repository is an open-source project to created to help with the problem of unsupported dependencies. Anyone in the community can submit GraalVM configuration to the project","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"https://github.com/oracle/graalvm-reachability-metadata","type":"SimpleText"}]}]}],"lastModifiedTime":1661114960850,"tocItem":{"chapterTitle":"Getting Started","pageTitle":"GraalVM on AWS Lambda","pageMeta":{"title":["GraalVM on AWS Lambda"]},"dirName":"getting-started","fileName":"summary","viewOnRelativePath":null,"pageSectionIdTitles":[{"title":"Overview","id":"overview"},{"title":"Advantages","id":"advantages"},{"title":"Limitations","id":"limitations"},{"title":"Dependency Considerations","id":"dependency-considerations"}]}},{"type":"Page","content":[{"id":"additional-training-resources","title":"Additional Training Resources","type":"Section","content":[{"type":"Paragraph","content":[{"url":"https://catalog.workshops.aws/java-on-aws-lambda/en-US","isFile":false,"type":"Link","content":[{"text":"Java on AWS Lambda","type":"SimpleText"}]},{"text":" - AWS Workshop","type":"SimpleText"}]},{"type":"Paragraph","content":[{"url":"https://objectcomputing.com/services/training/catalog/micronaut-training/micronaut-aws-lambda","isFile":false,"type":"Link","content":[{"text":"Jumpstart your Micronaut Applications with AWS Lambda","type":"SimpleText"}]},{"text":" - AWS Partner / Object Computing","type":"SimpleText"}]}]}],"lastModifiedTime":1661114960850,"tocItem":{"chapterTitle":"Getting Started","pageTitle":"Training Resources","pageMeta":{},"dirName":"getting-started","fileName":"training-resources","viewOnRelativePath":null,"pageSectionIdTitles":[{"title":"Additional Training Resources","id":"additional-training-resources"}]}}]